# 공부 알고리즘 범위

- 선택 정렬(Selection Sort)
- 거품 정렬(Bubble Sort)
- 병합 정렬(Merge Sort)
- 삽입 정렬(Insertion Sort)
- 퀵 정렬(Quick Sort)
- 힙 정렬(Heap Sort)
- 투포인터 알고리즘
- 순열(Permutation)
- BFS & DFS
- 이분 탐색(Binary Search)
- 최대공약수와 최소공배수
- lru cache

## 01. 선택 정렬

- 해당 순서에 원소를 넣을 위치를 이미 정해 놓고, 어떤 원소를 넣을지 선택하는 알고리즘
- 원소의 선택에 있어 작냐, 크냐에 따라 `최소 선택 정렬(오름차순)` `최대 선택 정렬(내림차순)`로 구분된다.
- 알고리즘 (최소 선택 정렬)
  1. 배열에서 첫번째 인덱스를 기준으로 잡는다.
  2. 배열에서 기준 이후의 값 중 최소값을 찾는다.
  3. 최소값과 기준의 값을 교체한다.
  4. 기준을 하나씩 오른쪽으로 이동하면서 2~3번을 반복한다.
- 예제
  1. [**1** 6 2 4 3 9 7]
  2. [1 **2** **6** 4 3 9 7]
  3. [1 2 **3** 4 **6** 9 7]
  4. [1 2 3 **4** 6 9 7]
  5. [1 2 3 4 **6** 9 7]
  6. [1 2 3 4 6 **7** **9**]
  7. [1 2 3 4 6 7 **9**]
- 시간 복잡도, 공간 복잡도
  - 최악, 최선, 평균 시간 복잡도: $O(\frac{n*(n - 1)}{2}) \sim O(n^2)$
  - 주어진 배열 안에서만 정렬 수행: $O(n)$
- 장점
  - 단순한 알고리즘이다.
  - 비교 연산에 비해 교환 횟수는 적다. 많은 교환이 일어나야 하는 자료 상태에 효율적
  - 다른 메모리 공간을 필요로 하지 않는다.
- 단점
  - 시간 복잡도가 $O(n^2)$으로 비효율적이다.
  - **불안정 정렬이다.**

## 02. 거품 정렬

- 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 알고리즘
  1. 1회전에서 [1, 2] 원소 비교 후 큰 원소를 뒤로 보내고, [2, 3] 원소 비교 후 뒤로 보내는 작업을 배열의 끝까지 진행
  2. 1회전 후 맨 마지막 원소는 가장 큰 원소가 되므로 2, 3, 4회전을 반복하여 마지막 원소부터 차례로 이동 시킨다.
- 예제

```
1단계 : 6 2 4 3 7 1 9 
2단계 : 2 4 3 6 1 7 9 
3단계 : 2 3 4 1 6 7 9 
4단계 : 2 3 1 4 6 7 9 
5단계 : 2 1 3 4 6 7 9 
6단계 : 1 2 3 4 6 7 9 
7단계 : 1 2 3 4 6 7 9 
```

- 시간 복잡도, 공간 복잡도
  - 최악, 최선, 평균 시간 복잡도: $O(\frac{n*(n - 1)}{2}) \sim O(n^2)$
  - 주어진 배열 안에서만 정렬 수행: $O(n)$

- 장점
  - 단순한 알고리즘이다.
  - 이미 정렬된 데이터를 정렬 시 가장 빠르다.
  - 다른 메모리 공간을 필요로 하지 않는다.
  - **안정 정렬이다.**
- 단점
  - 시간 복잡도가 $O(n^2)$으로 비효율적이다.
  - 다른 정렬에 비해 정렬 속도가 느리다.
  - 교환 횟수가 많다.
  - 역순배열을 정렬 시 가장 느리다.

## 03. 병합 정렬

- 요소를 쪼갠 후, 다시 합병시키면서 정렬해나가는 방식
- ​



## 추가적으로 조사

- 불안정 정렬? 그럼 안정 정렬도 존재? 그 둘의 차이는?? -> 간단히 정리 필요